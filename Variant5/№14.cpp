#include <iostream>
#include <ctime> //Делаем рандом не одинаковым при повторном запуске программы

using namespace std; //Подключили пространство имен std для работы с cout и cin

struct toch //Создаем структуру для создания очереди
{
	int inf; //Информация, хранимая в элемента
	toch *a; //Ссылка на следующий элемент очереди
};

//Функция добаления элемента в очередь
void add(toch **sp, toch **spk, int inf)  //sp - указатель на указатель первого элемента очереди
										  //spk - указатель на указатель последнего элемента очереди
{										  //inf - информационная часть нового элемента	
	toch *spt = new toch;	//выделяем память под новый элемент
	spt->inf = inf;	//Информационная часть нового элемента инициализируется как inf, переданный в функцию как аргумент(13 строка 3 аргумент)
	spt->a = NULL;	//Так как в очереди новый элемент становится первым, то логично, что у первого нет указателя на следующий, поэтому делаем NULL
	if (*spk == NULL) //Если отсутствует указатель на последний элемент очереди(то есть его попросту нет)
		*sp = *spk = spt; //То новый элемент становится первым и последним одновременно
	else //Иначе
	{
		(*spk)->a = spt; //Записываем элемент в конец очереди (обычная очередь как в магазине - пришел встал в конец)
		*spk = spt; //Переставляем указатель на последний элемент на только что добавленный, так как он теперь последний
	}
}

//Функция удаления очереди
void deloch(toch **sp, toch **spk) //sp - первый элемент, spk - последний элемент очереди (указатель на указатель для работы с адресами, то есть работы на прямую)
{
	toch *spt; //Создаем временный элемент
	while (*sp != NULL)//пока первый элемент существует
	{
		spt = *sp; //Записываем в временный элемент ссылку на первый
		*sp = (*sp)->a; //Переходим от первого ко второму
		delete spt; //Удаляем временный из памяти
	}//То есть, записали адрес текущего элемента в временную переменную, перескочили от текущего к следующему и удалили адрес, хранимый во временной
	*spk = NULL;//Обнулили указатель на последний элемент, так как мы все к хуям удалили(очередь всю)
}

//Функция вывода очереди
void showoch(toch *sp, toch *spk) //sp - указатель на 1-й, spk - указатель на последний
{								
	while (sp)//Пока sp != NULL, то есть пока sp хранит в себе какое-то значение(Информационная часть)
	{
		cout << sp->inf << " "; //Выводим Информационную часть
		sp = sp->a;//Переходим к следующему
	}//Используем не указатель на указатель, так как работаем не напрямую с sp, а только с элементом такого же типа данных
	cout << endl; //Ну тут пояснять не буду, ты же не даун
}


int main()
{
	toch *sp, *spk; //Создаем указатель на первый и последний элементы очереди
	sp = spk = NULL; //Так как пока что очереди не существует - им не на что указывать,(NULL = ничто в данном случае)
	int n, k; //n - длина очереди
	cout << "vvedi n: ";
	cin >> n;
	if (n<1) return 0; //Если пользовтель конченный долбаеб и захотел создать очередь с отрицательной длинной или длинной меньше нуля,
					//то блять давай все закроем нахуй(программа просто закончит выполнение),
					//нет блять чтобы while(n < 1) cin >> n написать,так хуйню какую-то высрали
	for (int i = 0; i < n; i++) //Цикл заполнения очереди
	{
		k = rand() % 101 - 50; //элементами в диапазоне от -50 до 50
		add(&sp, &spk, k); //Добавляем элемент в очередь - передаем адрем (то есть через &), так как там указатель на указатель и работаем
							//с элементами на прямую
	}
	showoch(sp, spk); //Выводим очередь в консоль
	toch *p, *t; //Создаем два указателя типа touch
	p = sp;	//В один из них записываем ссылку на первый элемент очереди
	t = NULL; //Второй пока что = NULL

	while (p) //пока p != NULL, то есть пока очередь не закончилась
	{
		if (p->a == NULL) break; //Если нет следующего элемента заканчиваем цикл
		t = p->a; //Записываем в t адрес следующего после текущего (грубо говоря работаем сейчас с n-ым , а записываем в t n+1 -й)
		p = p->a = p->a->a;//В текущий и следующий пишем после следующий(то есть n = n+2 и n+1 = n+2)
		delete t;//Удаляем t
	}

	showoch(sp, spk); //Выводим очередь
	deloch(&sp, &spk);//Удаляем очередь к хуям собачим
	system("pause");
	return 0;
}
